---
title: "Multistate capture-recapture and mark-recovery models"
author: "Frederic Barraquand"
date: "February 14, 2019"
output:
  pdf_document: default
  number_sections: yes
  word_document: null
header-includes:
- \usepackage{setspace}
- \doublespacing
- \usepackage{lineno}
- \linenumbers
csl: ecology.csl
bibliography: /home/frederic/Dropbox/database/total.bib
---

## Intro

We need a model combining both CMR and mark-recovery (dead individuals)

## Create a matrix of capture histories

```{r}
dringed<-read.csv("data/Gyrs_ringed.csv")
head(dringed) # What's in the data table
length(unique(dringed$Ring_No)) #How many unique bird IDs
```

OK, so we have 1653 unique IDs. Let's compare to how many gyrs have been recovered. 

```{r}
drecov<-read.csv("data/Gyrs_recovered.csv")
head(drecov)
length(unique(drecov$Ring_No)) #How many unique bird IDs in Gyrs_recovered.csv
```

Actually we need a mixture of mark-recovery and CMR. p. 295 Kery and Schaub. 
In our case, not all individuals in the recently dead state move to the "dead" state at t+1. This is because recently dead individuals can be recovered still after t+1 (although we should probably set a prior that makes this probability fairly high).  

Let's compute capture histories (without distinguish young and old for now?)

```{r}
Birds_ringed = unique(dringed$Ring_No)
Birds_recov = unique(drecov$Ring_No)
min_year = min(dringed$Ringed_year)
max_year = max(dringed$Ringed_year)
min_year
max_year
### check
min(drecov$Year_recorded)
max_year = max(drecov$Year_recorded) #because it's 2018
timespan = min_year:max_year
time_index = 1:length(timespan)
time_index_max = length(timespan)
CH = matrix(NA,nrow=nrow(dringed),ncol=time_index_max)

for (i in 1:nrow(dringed))
{
    ## if it's ringed, we put a 1 on capture year
    year_ringed = dringed$Ringed_year[i]-min_year+1
    CH[i,year_ringed] = 1
  if (dringed$Ring_No[i] %in% Birds_recov)
  {
    ## Keep in mind they can be recorded several times
    dates_recov = drecov$Year_recorded[drecov$Ring_No == as.character(dringed$Ring_No[i])]
    type_recov = drecov$Condition_Euring_code[drecov$Ring_No == as.character(dringed$Ring_No[i])]
    
    for (d in 1:length(dates_recov)){
        year_recov = dates_recov[d]-min_year+1
         if  (type_recov[d] %in% c(4,7,8)){ #live recovery
           CH[i,year_recov] = 1
         } 
         else {CH[i,year_recov] = 2}
      }#end of for loop on all dates where the bird was recorded

  }#end of if condition on whether the bird was captured
  else {
    CH[i,year_ringed:time_index_max] = 3
  }
  
}

CH[is.na(CH)]=3
library('RColorBrewer')
library('fields')
cols = brewer.pal(3,"RdBu")
rf <- colorRampPalette(cols)   # make colors
# voir aussi  http://www.sthda.com/french/wiki/couleurs-dans-r
image.plot(1:nrow(dringed),timespan,CH,col=cols)

#Verif of data by blocks
time1=1
time2=250
image.plot(time1:time2,timespan,CH[time1:time2,],col=cols)

time1=250
time2=500
image.plot(time1:time2,timespan,CH[time1:time2,],col=cols)

time1=500
time2=750
image.plot(time1:time2,timespan,CH[time1:time2,],col=cols)
## A number of individuals are either recaptured dead the same year or there is a date problem



time1=750
time2=1000
image.plot(time1:time2,timespan,CH[time1:time2,],col=cols)

time1=1000
time2=1250
image.plot(time1:time2,timespan,CH[time1:time2,],col=cols)

time1=1250
time2=nrow(dringed)
image.plot(time1:time2,timespan,CH[time1:time2,],col=cols)

write.csv(CH,file = "data/CaptureHistories.csv")

```

Troubleshoot cases where the year of marking is also the year where the bird has been recorded dead

```{r}
### Create data structure where the recovery information is appended to ringed birds dataframe

```



## Fit the CJS model

---

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
summary(cars)
```

You can also embed plots, for example:

```{r, echo=FALSE}
plot(cars)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
